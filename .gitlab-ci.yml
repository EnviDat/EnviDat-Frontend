stages:
  - config
  - install
  - test
  - build
#  - package
  - deploy
#  - release

variables:
  ARTIFACT_COMPRESSION_LEVEL: "fast"
  CACHE_COMPRESSION_LEVEL: "fast"
  npm_config_cache: '$CI_PROJECT_DIR/.npm'


# defined a template for the jobs with node, insteaad of defining a global cache for all jobs
.node_cache:
  cache:
    # uses the package-lock.json as key to determine if the node_mdules can be used from cache
    - key:
        files:
          - package-lock.json
        prefix: "package-lock-$CI_COMMIT_REF_NAME"
      paths:
        - node_modules/
      policy: pull  # prevent subsequent jobs from modifying cache


.trigger-rules:
  rules:
    - if: '$CI_COMMIT_REF_NAME =~ /^(main|staging|develop|beta)$/'
      changes:
        - 'src/**/*'
        - 'public/**/*'
        - 'tests/**/*'
        - 'nginx/**/*'
        - 'chart/**/*'
        - '.env*'
        - 'package.json*'
        - 'vue.*'
        - 'Dockerfile'
        - '.gitlab-ci.yml'
#       using when: always will run all jobs regardless of previous failures?
#      when: always
    - if: $CI_PIPELINE_SOURCE == "web"
      when: always

set-vars:
  stage: .pre
  image: docker.io/alpine:3.15
  rules:
    - !reference [.trigger-rules, rules]
    - if: $CI_COMMIT_TAG
  before_script:
    - >
      apk add jq yq --no-cache
      --repository=https://dl-cdn.alpinelinux.org/alpine/edge/community
  script:
    # extract version number from package.json, to make it available in the app
    - >
      echo "VERSION=$(jq '.version' package.json --raw-output)" >> build.env
    # move all variables from the from the CI / CD into the build variables
    - cat .env >> build.env
    - |
      if [ "${CI_COMMIT_REF_NAME}" == "develop" ]; then
        echo "CI_COMMIT_REF_NAME=dev" >> build.env
      fi
    # bash "source" command loads all the variables from the file
    - source build.env
    # extract version number from package.json, to make it available in the app (to be able to use VERSION)
    # - >
    #  echo "IMAGE_NAME=${INTERNAL_REG}/envidat-frontend:${VERSION}-${CI_COMMIT_REF_NAME}"
    #  >> build.env
    - echo "BUILD_NAME=${VERSION}-${CI_COMMIT_REF_NAME}" >> build.env
    - echo "BUILD_ZIP_NAME=envidat-frontend-${BUILD_NAME}.zip" >> build.env
    - echo "content of build.env"
    - cat build.env
  artifacts:
    reports:
      dotenv: build.env

modify-env:
  extends: .trigger-rules
  stage: config
  image: docker.io/python:3.9-alpine3.17
  dependencies:
    - set-vars
  before_script:
    - pip install --upgrade pip
    - pip install python-dotenv==0.19.*
  script:
    - |
      python -c "import os
      import dotenv

      file = '.env.production'
      branch = os.getenv('CI_COMMIT_REF_NAME')

      key = 'VITE_DOMAIN'
      value = f'https://{branch}.envidat.ch'
      if branch == 'main' or branch == 'beta':
          value = 'https://envidat.ch'
      dotenv.set_key(file, key, value, quote_mode='never')

      key = 'VITE_API_ROOT'
      value = f'https://{branch}.envidat.ch'
      if branch == 'main' or branch == 'beta':
          value = 'https://envidat.ch'
      dotenv.set_key(file, key, value, quote_mode='never')

      key = 'VITE_CONFIG_URL'
      value = f'https://frontend-config.s3-zh.os.switch.ch/{branch}.json'
      dotenv.set_key(file, key, value, quote_mode='never')
      
      key = 'VITE_BUILD_SOURCEMAPS'
      value = 'false'
      if branch == 'staging' or branch == 'develop':
          value = 'true'
      dotenv.set_key(file, key, value, quote_mode='never') "
    - echo "created content for .env.production:"
    - cat .env.production
  artifacts:
    name: "environment variables"
    paths:
      - .env.production

install-node:
  extends:
    - .trigger-rules
    - .node_cache
  stage: install
  image: docker.io/node:18.18.2-alpine3.17
  cache:
    # for all install job use the npm internal caching
    - key: "Commit-$CI_COMMIT_REF_NAME"
      paths:
        - .npm/
      when: on_success
      policy: pull-push
    # overwrite the global cachine definitions with
    # pull-push to be able update the node_modules in the cache
    - key:
        files:
          - package-lock.json
        prefix: "package-lock-$CI_COMMIT_REF_NAME"
      paths:
        - node_modules/
      when: on_success
      policy: pull-push
  script:
    - echo "used cache job for .npm Commit-${CI_COMMIT_REF_NAME}"
    - echo "used cache job for node_modules package-lock-${CI_COMMIT_REF_NAME}"
    - npm ci --cache .npm --prefer-offline
  artifacts:
    name: "node dependencies"
    # stores node_modules as an artifact to be used in the next jobs
    # caching isn't garanteed to work always
    paths:
      - node_modules

run-tests:
  extends:
    - .trigger-rules
    - .node_cache
  stage: test
  image: docker.io/node:18.18.2-alpine3.17
  needs:
    - modify-env
    - install-node
  script:
    - npm run test

build-storybook:
  extends:
    - .trigger-rules
    - .node_cache
  stage: build
  image: docker.io/node:18.18.2-alpine3.17
  needs:
    # needs the artifact: config and environment variables
    - modify-env
    # needs the artifact: node_modules to build storybook
    - install-node
  script:
    - npm run build-storybook -- -o ./storybook
  artifacts:
    name: "storybook build"
    expire_in: 1 day
    # stores the storybook build as an artifact to be used in the next stages
    paths:
      - storybook

build-app:
  extends:
    - .trigger-rules
    - .node_cache
  stage: build
  image: docker.io/node:18.18.2-alpine3.17
  needs:
    # needs the artifact: config and environment variables
    - modify-env
    # needs the artifact: node_modules to build the app
    - install-node
  script:
    - npm run build
  artifacts:
    name: "frontend build "
    expire_in: 1 day
    # stores the built app code
    paths:
      - dist

combine-builds:
  extends: .trigger-rules
  stage: build
  image: docker.io/alpine:3.15
  variables:
    GIT_STRATEGY: none
  needs:
    # needs the artifact: the build of the frontend app
    - build-app
    # needs the artifact: storybook
    - build-storybook
  script:
    - echo "Check for the artifacts in the filesystem"
    - ls -l
    # - ls dist/ -l
    # - ls storybook/ -l
    # copy all files from the dist folder into root
    - cp -r dist/* ./
    # - ls -l
    # remove the dist folder recursively
    - rm -rf dist
    - ls -l
  artifacts:
    name: "frontend build $CI_COMMIT_REF_NAME"
    expire_in: 1 month
    # stores the combined built code
    paths:
      - ./


deploy-chromatic:
  extends: .node_cache
  stage: deploy
  image: docker.io/node:18.18.2-alpine3.17
  variables:
    GIT_STRATEGY: none
  needs:
    # needs the artifact: config and environment variables
    - modify-env
    # needs the artifact: node_modules to build the app
    - install-node
    # needs the artifact: storybook
    - build-storybook
  script:
    # manually deploy the storybook build to chromatic for visual regression testing
    - npx chromatic --project-token=${CHROMATIC_PROJECT_TOKEN} --exit-zero-on-changes --storybook-build-dir ./storybook
  when: manual

#tag-commit-sha:
#  extends: .trigger-rules
#  stage: package
#  image: docker.io/regclient/regctl:v0.3-alpine
#  variables:
#    GIT_STRATEGY: none
#  before_script:
#    - export REG_HOST=${INTERNAL_REG%/*}
#    - >
#      echo "{\"hosts\":{\"${REG_HOST}\":{\"tls\":\"enabled\",\"hostname\":
#      \"${REG_HOST}\",\"user\":\"${IMAGE_REGISTRY_USER}\",\"pass\":
#      \"${IMAGE_REGISTRY_PASS}\"}}}" >> /home/appuser/.regctl/config.json
#  script:
#      - >
#        regctl --verbosity debug image copy
#        "${IMAGE_NAME}" "${INTERNAL_REG}/envidat-frontend:${CI_COMMIT_SHA}"


publish-build:
  extends: .trigger-rules
  stage: deploy
  image: docker.io/alpine:3.15
  variables:
    GIT_STRATEGY: none
    # BUILD_NAME: "${VERSION}-${CI_COMMIT_REF_NAME}"
    # BUILD_ZIP_NAME: "envidat-frontend-${BUILD_NAME}.zip"
  needs:
    # needs the enviromental variables for the version number
    - set-vars
    # needs the artifact: the build of the frontend app and storybook build
    - combine-builds
  before_script:
    - apk add curl zip --no-cache
  script:
    - echo "Going to publish build ${BUILD_NAME} with zip name ${BUILD_ZIP_NAME}"
    - zip -r ${BUILD_ZIP_NAME} ./
    - ls -l
    # https://gitlabext.wsl.ch/api/v4/projects/129/packages/generic/envidat-frontend/${VERSION}-${CI_COMMIT_REF_NAME}/
    # - PUT /projects/:id/packages/generic/:package_name/:package_version/:file_name?status=:status
    - |
      curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
      --user "${CI_DEPLOY_USER}:${CI_DEPLOY_PASSWORD}" \
      --upload-file ${BUILD_ZIP_NAME} \
      "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/envidat-frontend/${BUILD_NAME}/${BUILD_ZIP_NAME}"
      


rclone-sync:
  extends: .trigger-rules
  stage: deploy
  image: docker.io/alpine:3.15
  needs:
    # needs the enviromental variables for the version number
    - set-vars
    # make sure to wait for the tests to run correctly
    - run-tests
    # needs the artifact from the build jobs for the app and it's storybook
    - combine-builds
  variables:
    GIT_STRATEGY: none
    RCLONE_CONFIG_SWITCH_TYPE: 's3'
    RCLONE_S3_PROVIDER: 'Other'
    RCLONE_S3_ENV_AUTH: 'true'
  before_script:
    - apk add curl unzip --no-cache
    - curl -O https://downloads.rclone.org/v1.59.0/rclone-v1.59.0-linux-amd64.zip
    - unzip rclone-v1.59.0-linux-amd64.zip
    - cp rclone-v1.59.0-linux-amd64/rclone /usr/bin/
    - rm rclone-v1.59.0-linux-amd64.zip
    - rm -rf rclone-v1.59.0-linux-amd64
    - |
      if [ "${CI_COMMIT_REF_NAME}" == "main" ]; then
        BUCKET_NAME="frontend"
      else
        BUCKET_NAME="frontend-${CI_COMMIT_REF_NAME}"
      fi
      if [ "${CI_COMMIT_REF_NAME}" == "develop" ]; then
        BUCKET_NAME="frontend-dev"
      fi
      echo "Going to rclone sync to the bucket: '${BUCKET_NAME}'"
  script:
    - echo "Going to pull build ${BUILD_NAME} with zip name ${BUILD_ZIP_NAME}"
    - ls -l
    - |
      curl --header "JOB-TOKEN: ${CI_JOB_TOKEN}" \
      --user "${CI_DEPLOY_USER}:${CI_DEPLOY_PASSWORD}" \
      "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/envidat-frontend/${BUILD_NAME}/${BUILD_ZIP_NAME}"
    - unzip ${BUILD_ZIP_NAME}
    - rm ${BUILD_ZIP_NAME}
    - ls -l
    - echo "going to rclone sync from ./ to switch:${BUCKET_NAME}"
    - rclone sync ./ "switch:${BUCKET_NAME}" --verbose
#    - >
#      rclone --verbose sync
#      /usr/share/nginx/html/ "switch:${BUCKET_NAME}"
